diff --git a/frontend/src/App.jsx b/frontend/src/App.jsx
index f22eec15fc72ae3832b2a98ce1430dd5a351b606..7b3b7fde3a9691831c383dbb7b487bce621646f1 100644
--- a/frontend/src/App.jsx
+++ b/frontend/src/App.jsx
@@ -1,31 +1,32 @@
 import React, { useEffect, useMemo, useState } from 'react';
 import { BrowserRouter, Routes, Route, Link, Navigate, useLocation, useNavigate } from 'react-router-dom';
 import axios from 'axios';
 
 const API = 'http://localhost:8000';
 const DEFAULT_SERVICE_CHARGE = 10;
+const SERVICE_CHARGE_STORAGE_KEY = 'bookitgy.service_charge_rate';
 
 const sampleProviders = [
   {
     id: 1,
     name: 'Ariana De Freitas',
     location: 'Georgetown',
     lat: 6.8013,
     long: -58.155,
     outstanding: 32000,
     credit: 5000,
     isLocked: false,
     lastActive: '2024-10-10',
     totalBookings: 42,
     cancellations: 3,
     noShows: 1,
     services: ['Makeup', 'Hair Styling'],
   },
   {
     id: 2,
     name: 'Jamall Adams',
     location: 'East Bank',
     lat: 6.7484,
     long: -58.2439,
     outstanding: 18000,
     credit: 0,
@@ -73,50 +74,63 @@ const sampleCharges = [
   { id: 102, providerId: 1, month: '2024-09-01', amount: 15000, isPaid: true },
   { id: 103, providerId: 2, month: '2024-10-01', amount: 9000, isPaid: false },
   { id: 104, providerId: 3, month: '2024-10-01', amount: 22000, isPaid: false },
   { id: 105, providerId: 4, month: '2024-10-01', amount: 12000, isPaid: true },
 ];
 
 const sampleBookings = [
   { id: 1, providerId: 1, clientId: 10, status: 'completed', startTime: '2024-10-12T12:00:00Z' },
   { id: 2, providerId: 1, clientId: 11, status: 'cancelled', startTime: '2024-10-12T15:00:00Z' },
   { id: 3, providerId: 2, clientId: 12, status: 'completed', startTime: '2024-10-11T16:00:00Z' },
   { id: 4, providerId: 2, clientId: 13, status: 'pending', startTime: '2024-10-10T10:00:00Z' },
   { id: 5, providerId: 3, clientId: 14, status: 'no-show', startTime: '2024-10-01T10:00:00Z' },
   { id: 6, providerId: 4, clientId: 10, status: 'completed', startTime: '2024-10-12T09:00:00Z' },
   { id: 7, providerId: 4, clientId: 16, status: 'cancelled', startTime: '2024-09-15T09:00:00Z' },
   { id: 8, providerId: 1, clientId: 15, status: 'completed', startTime: '2024-10-10T09:00:00Z' },
 ];
 
 const signupHistory = [
   { month: 'Jun', providers: 10, clients: 54 },
   { month: 'Jul', providers: 14, clients: 62 },
   { month: 'Aug', providers: 21, clients: 70 },
   { month: 'Sep', providers: 33, clients: 82 },
   { month: 'Oct', providers: 40, clients: 95 },
 ];
 
+const normalizeServiceCharge = (value) => Math.max(0, Math.min(100, Number(value) || 0));
+
+const loadStoredServiceCharge = () => {
+  const stored = localStorage.getItem(SERVICE_CHARGE_STORAGE_KEY);
+  if (stored === null) return null;
+
+  return normalizeServiceCharge(stored);
+};
+
+const persistServiceCharge = (rate) => {
+  localStorage.setItem(SERVICE_CHARGE_STORAGE_KEY, String(rate));
+};
+
 function Login({ onLogin }) {
   const [email, setEmail] = useState('admin@guyana.com');
   const [password, setPassword] = useState('pass');
   const navigate = useNavigate();
 
   const login = async () => {
     try {
       const res = await axios.post(`${API}/auth/login`, new URLSearchParams({
         username: email,
         password: password,
       }));
       const token = res.data.access_token;
       localStorage.setItem('token', token);
       axios.defaults.headers.common.Authorization = `Bearer ${token}`;
       onLogin?.(token);
       navigate('/admin');
     } catch {
       alert('Wrong credentials');
     }
   };
 
   return (
     <div
       style={{
         minHeight: '100vh',
@@ -470,62 +484,72 @@ function AdminDashboard() {
       map[p.id] = p;
     });
     return map;
   }, [providers]);
 
   const topProviders = Object.entries(bookingCountsByProvider)
     .sort((a, b) => b[1] - a[1])
     .slice(0, 3)
     .map(([providerId, count]) => ({
       name: providerById[providerId]?.name || `Provider ${providerId}`,
       bookings: count,
     }));
 
   const applyCredit = (providerId) => {
     const creditValue = Number(creditInputs[providerId] || 0);
     if (!creditValue) return;
     setProviders((prev) =>
       prev.map((p) =>
         p.id === providerId ? { ...p, credit: p.credit + creditValue, outstanding: Math.max(0, p.outstanding - creditValue) } : p,
       ),
     );
     setCreditInputs((prev) => ({ ...prev, [providerId]: '' }));
   };
 
   const recalculateChargesForRate = (rate) => {
-    const safeRate = Math.max(0, Math.min(100, Number(rate) || 0));
+    const safeRate = normalizeServiceCharge(rate);
     setCharges((prev) => prev.map((c) => ({ ...c, amount: Math.round(c.baseServiceCost * (safeRate / 100)) })));
     setServiceCharge(safeRate);
     setServiceChargeDraft(safeRate);
   };
 
+  useEffect(() => {
+    const storedRate = loadStoredServiceCharge();
+    if (storedRate !== null) {
+      recalculateChargesForRate(storedRate);
+    }
+  }, []);
+
   const saveServiceCharge = () => {
-    recalculateChargesForRate(serviceChargeDraft);
+    const safeRate = normalizeServiceCharge(serviceChargeDraft);
+    persistServiceCharge(safeRate);
+    recalculateChargesForRate(safeRate);
   };
 
   const resetServiceCharge = () => {
     recalculateChargesForRate(DEFAULT_SERVICE_CHARGE);
+    localStorage.removeItem(SERVICE_CHARGE_STORAGE_KEY);
   };
 
   const toggleLock = (providerId) => {
     setProviders((prev) => prev.map((p) => (p.id === providerId ? { ...p, isLocked: !p.isLocked } : p)));
   };
 
   const toggleChargeSelection = (chargeId) => {
     setSelectedChargeIds((prev) => (prev.includes(chargeId) ? prev.filter((id) => id !== chargeId) : [...prev, chargeId]));
   };
 
   const toggleAllChargesSelection = () => {
     if (selectedChargeIds.length === charges.length) {
       setSelectedChargeIds([]);
     } else {
       setSelectedChargeIds(charges.map((c) => c.id));
     }
   };
 
   const setChargesPaidState = (paidState) => {
     setCharges((prev) => prev.map((c) => (selectedChargeIds.includes(c.id) ? { ...c, isPaid: paidState } : c)));
     setSelectedChargeIds([]);
   };
 
   const updateSingleChargeStatus = (chargeId, paidState) => {
     setCharges((prev) => prev.map((c) => (c.id === chargeId ? { ...c, isPaid: paidState } : c)));
