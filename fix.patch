 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/frontend/src/App.jsx b/frontend/src/App.jsx
index 04abda75bbaad32fe3e900e871b5880e8b36c3e7..9a85f77ba619dfee11d2463bd55cef73ca07899c 100644
--- a/frontend/src/App.jsx
+++ b/frontend/src/App.jsx
@@ -135,91 +135,128 @@ const isPastSuspensionCutoff = () => {
 
 function useBillingCore() {
   const billingCycleStart = useMemo(() => {
     const today = new Date();
     return new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), 1)).toISOString().slice(0, 10);
   }, []);
 
   const [providers, setProviders] = useState(sampleProviders);
   const [charges, setCharges] = useState(() =>
     sampleCharges.map((charge) => {
       const baseServiceCost = Math.round((charge.amount / DEFAULT_SERVICE_CHARGE) * 100);
 
       return {
         ...charge,
         baseServiceCost,
         isPaid: charge.month === billingCycleStart ? false : charge.isPaid ?? false,
       };
     }),
   );
   const [selectedChargeIds, setSelectedChargeIds] = useState([]);
   const [creditInputs, setCreditInputs] = useState({});
   const [loadingProviders, setLoadingProviders] = useState(false);
   const [suspensionClock, setSuspensionClock] = useState(() => Date.now());
   const suspensionCutoffLabel = useMemo(() => getSuspensionCutoffDate().toISOString().slice(0, 10), []);
 
+  useEffect(() => {
+    const storedToken = localStorage.getItem('token');
+    if (storedToken) {
+      axios.defaults.headers.common.Authorization = `Bearer ${storedToken}`;
+    }
+  }, []);
+
   useEffect(() => {
     const interval = setInterval(() => setSuspensionClock(Date.now()), 1000 * 60 * 30);
     return () => clearInterval(interval);
   }, []);
 
   useEffect(() => {
     const fetchProviders = async () => {
       try {
         setLoadingProviders(true);
         const res = await axios.get(`${API}/providers`);
         if (Array.isArray(res.data) && res.data.length) {
           const normalized = res.data.map((p) => ({
             id: p.provider_id || p.id,
             name: p.name || 'Provider',
             accountNumber: p.account_number || p.accountNumber || '—',
             phoneNumber: p.phone || p.phone_number || '—',
             location: p.location || 'Unknown area',
             lat: p.lat,
             long: p.long,
             outstanding: Math.floor(Math.random() * 40000) + 5000,
             credit: 0,
             isLocked: false,
             autoSuspended: false,
             lastActive: '2024-10-10',
             totalBookings: Math.floor(Math.random() * 40) + 5,
             cancellations: Math.floor(Math.random() * 5),
             noShows: Math.floor(Math.random() * 2),
             services: p.services || [],
           }));
           setProviders(normalized);
         }
       } catch (e) {
         console.log('Using sample providers', e.message);
       } finally {
         setLoadingProviders(false);
       }
     };
 
     fetchProviders();
   }, []);
 
+  useEffect(() => {
+    const fetchBilling = async () => {
+      try {
+        const res = await axios.get(`${API}/admin/billing`);
+        if (!Array.isArray(res.data) || res.data.length === 0) return;
+
+        setCharges(
+          res.data.map((row) => {
+            const amount = Number(row.amount_due_gyd ?? 0);
+            return {
+              id: row.provider_id ?? row.id,
+              providerId: row.provider_id ?? row.id,
+              providerName: row.name || 'Provider',
+              accountNumber: row.account_number || row.accountNumber || '—',
+              phoneNumber: row.phone || row.phone_number || '—',
+              month: billingCycleStart,
+              amount: Math.round(amount),
+              baseServiceCost: 0,
+              isPaid: !!row.is_paid,
+            };
+          }),
+        );
+      } catch (e) {
+        console.log('Using sample billing data', e.message);
+      }
+    };
+
+    fetchBilling();
+  }, [billingCycleStart]);
+
   useEffect(() => {
     setCharges((prev) => {
       if (!providers.length) return prev;
 
       let nextId = prev.reduce((max, c) => Math.max(max, c.id), 0) + 1;
       let updated = [...prev];
 
       providers.forEach((provider) => {
         const existing = updated.find((c) => c.providerId === provider.id);
         if (!existing) {
           const amount = provider.outstanding || Math.floor(Math.random() * 20000) + 5000;
           updated.push({
             id: nextId++,
             providerId: provider.id,
             month: billingCycleStart,
             amount,
             baseServiceCost: Math.round((amount / DEFAULT_SERVICE_CHARGE) * 100),
             isPaid: false,
           });
         }
       });
 
       return updated;
     });
   }, [providers, billingCycleStart]);
@@ -231,53 +268,53 @@ function useBillingCore() {
       prev.map((provider) => {
         const hasUnpaidCurrentCharge = charges.some(
           (charge) => charge.providerId === provider.id && charge.month === billingCycleStart && !charge.isPaid,
         );
         const autoSuspended = inSuspensionWindow && hasUnpaidCurrentCharge;
 
         if (provider.autoSuspended === autoSuspended) return provider;
 
         return { ...provider, autoSuspended };
       }),
     );
   }, [billingCycleStart, charges, suspensionClock]);
 
   const providerById = useMemo(() => {
     const map = {};
     providers.forEach((p) => {
       map[p.id] = p;
     });
     return map;
   }, [providers]);
 
   const resolvedCharges = useMemo(
     () =>
       charges.map((charge) => ({
         ...charge,
-        providerName: providerById[charge.providerId]?.name || 'Provider',
-        accountNumber: providerById[charge.providerId]?.accountNumber || '—',
-        phoneNumber: providerById[charge.providerId]?.phoneNumber || '—',
+        providerName: providerById[charge.providerId]?.name || charge.providerName || 'Provider',
+        accountNumber: providerById[charge.providerId]?.accountNumber || charge.accountNumber || '—',
+        phoneNumber: providerById[charge.providerId]?.phoneNumber || charge.phoneNumber || '—',
         isCurrentCycle: charge.month === billingCycleStart,
       })),
     [charges, providerById, billingCycleStart],
   );
 
   const applyCredit = (providerId) => {
     const creditValue = Number(creditInputs[providerId] || 0);
     if (!creditValue) return;
     setProviders((prev) =>
       prev.map((p) =>
         p.id === providerId ? { ...p, credit: p.credit + creditValue, outstanding: Math.max(0, p.outstanding - creditValue) } : p,
       ),
     );
     setCreditInputs((prev) => ({ ...prev, [providerId]: '' }));
   };
 
   const toggleLock = (providerId) => {
     setProviders((prev) => prev.map((p) => (p.id === providerId ? { ...p, isLocked: !p.isLocked } : p)));
   };
 
   const toggleChargeSelection = (chargeId) => {
     setSelectedChargeIds((prev) => (prev.includes(chargeId) ? prev.filter((id) => id !== chargeId) : [...prev, chargeId]));
   };
 
   const toggleAllChargesSelection = (chargeIds = charges.map((c) => c.id)) => {
 
EOF
)